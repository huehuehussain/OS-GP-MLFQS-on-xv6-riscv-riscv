\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf-8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\usepackage{times}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{booktabs}
\usepackage{array}

% Spacing
\onehalfspacing

% Code listing style
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    backgroundcolor=\color{gray!10},
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    breakatwhitespace=true,
    frame=single,
    rulecolor=\color{black!30},
    aboveskip=8pt,
    belowskip=8pt
}

% Header and Footer
\pagestyle{fancy}
\fancyhf{}
\rhead{MLFQ Scheduler -- Week 1}
\lhead{xv6-RISC-V}
\cfoot{Page \thepage\ of \pageref{LastPage}}

% Title
\title{\textbf{MLFQ Scheduler Implementation} \\ \large Week 1: Foundation and Data Structures}
\author{Computer Systems Implementation}
\date{\today}

\begin{document}

\maketitle

\section*{Overview}

Week 1 establishes the foundational infrastructure for Multi-Level Feedback Queue (MLFQ) scheduling on xv6-RISC-V. This phase includes designing the four-level queue architecture, implementing the \texttt{getprocinfo()} system call for process information retrieval, and integrating MLFQ fields into the process lifecycle. The groundwork enables sophisticated scheduling algorithms to be implemented in subsequent weeks.

\section{Architecture Design}

The MLFQ system uses four priority levels with exponential time quanta:

\begin{center}
\begin{tabular}{ccccl}
\toprule
\textbf{Level} & \textbf{Queue} & \textbf{Quantum} & \textbf{Priority} & \textbf{Purpose} \\
\midrule
0 & Q0 & 2 ticks & Highest & Interactive/I/O-bound \\
1 & Q1 & 4 ticks & High & Mixed workload \\
2 & Q2 & 8 ticks & Low & CPU-bound (medium) \\
3 & Q3 & 16 ticks & Lowest & CPU-bound (heavy) \\
\bottomrule
\end{tabular}
\end{center}

This exponential progression provides three key properties: (1) \textbf{Responsiveness}—high-priority queues use minimal quanta for quick context switches; (2) \textbf{Fairness}—low-priority queues receive extended execution ensuring CPU time; (3) \textbf{Simplicity}—four levels balance complexity with effectiveness.

\subsection{Promotion and Demotion Policy}

\textbf{Demotion:} When a process uses its full time quantum, it moves to the next lower priority queue (Q0 $\to$ Q1 $\to$ Q2 $\to$ Q3), with \texttt{time\_in\_queue} reset to zero.

\textbf{Priority Boost:} Every 100 ticks, all RUNNABLE processes are elevated to Q0, preventing indefinite starvation of lower-priority processes.

\textbf{I/O Behavior:} Processes that yield or block (via sleep/I/O) before exhausting their quantum do not demote. They remain at their current priority level, providing responsiveness for I/O-bound workloads.

\section{Data Structures}

The \texttt{struct proc} in \texttt{kernel/proc.h} is extended with four MLFQ fields:

\begin{lstlisting}[language=C]
struct proc {
  // ... existing xv6 fields ...
  int queue_level;        // Current priority queue (0-3)
  uint64 time_in_queue;   // Ticks used in current quantum
  uint64 time_slices;     // Total scheduling intervals
  struct proc *queue_next;// Linked list for queue management
};
\end{lstlisting}

The user-space interface is defined through \texttt{struct procinfo} in \texttt{user/user.h}:

\begin{lstlisting}[language=C]
struct procinfo {
  uint64 pid;           // Process identifier
  uint64 queue_level;   // Current queue (0-3)
  uint64 time_in_queue; // Ticks in current quantum
  uint64 time_slices;   // Total time slices received
};
\end{lstlisting}

\section{System Call Implementation}

The \texttt{getprocinfo()} syscall (SYS\_getprocinfo = 22) retrieves MLFQ information about the calling process:

\begin{lstlisting}[language=C]
uint64
sys_getprocinfo(void) {
  uint64 procinfo_ptr;
  struct procinfo info;
  
  if(argaddr(0, &procinfo_ptr) < 0)
    return -1;
  
  struct proc *p = myproc();
  info.pid = p->pid;
  info.queue_level = p->queue_level;
  info.time_in_queue = p->time_in_queue;
  info.time_slices = p->time_slices;
  
  if(copyout(p->pagetable, procinfo_ptr, 
             (char *)&info, sizeof(info)) < 0)
    return -1;
  return 0;
}
\end{lstlisting}

This implementation demonstrates secure kernel-to-userspace data transfer. The \texttt{copyout()} function validates the user pointer and handles page table translation, ensuring memory safety across the kernel boundary.

\subsection{User-Space Usage}

\begin{lstlisting}[language=C]
#include "user.h"

int main() {
  struct procinfo info;
  
  if(getprocinfo(&info) < 0) {
    printf("Error\n");
    exit(1);
  }
  
  printf("PID: %ld, Queue: %ld, Time: %ld\n",
         info.pid, info.queue_level, 
         info.time_in_queue);
  exit(0);
}
\end{lstlisting}

\section{Process Lifecycle Integration}

MLFQ fields are initialized in \texttt{allocproc()} during process creation:

\begin{lstlisting}[language=C]
p->queue_level = 0;      // Start at Q0 (highest)
p->time_in_queue = 0;    // No time used
p->time_slices = 0;      // Initial count
p->queue_next = 0;       // Not queued yet
\end{lstlisting}

Fields are cleaned during process termination in \texttt{freeproc()}. The key insight: all new processes begin at Q0. I/O-bound processes naturally remain there by yielding early, while CPU-bound processes demote by using their full quantum—this enables automatic I/O detection without explicit classification.

\section{Files Modified}

\begin{center}
\begin{tabular}{lll}
\toprule
\textbf{File} & \textbf{Changes} & \textbf{Lines} \\
\midrule
kernel/proc.h & MLFQ field definitions & 4 \\
kernel/proc.c & Field initialization & 4 \\
kernel/syscall.h & SYS\_getprocinfo = 22 & 1 \\
kernel/syscall.c & Dispatcher entry & 2 \\
kernel/sysproc.c & sys\_getprocinfo() implementation & 30 \\
kernel/defs.h & Function prototypes & 2 \\
user/user.h & struct procinfo definition & 8 \\
user/usys.pl & Syscall stub generation & 1 \\
\midrule
& \textbf{Total} & \textbf{~60} \\
\bottomrule
\end{tabular}
\end{center}

\section{Syscall Registration}

The syscall is registered through three components:

\begin{enumerate}
    \item \textbf{kernel/syscall.h:} Define \texttt{\#define SYS\_getprocinfo 22}
    \item \textbf{kernel/syscall.c:} Add to dispatcher array and external declaration
    \item \textbf{user/usys.pl:} Generate user-space stub via \texttt{entry("getprocinfo")}
\end{enumerate}

\section{Compilation and Verification}

Building the system:

\begin{lstlisting}[style=bash]
make clean && make && make fs.img
make qemu
$ getprocinfo_test
\end{lstlisting}

Expected behavior: All processes report \texttt{queue\_level=0} on initialization, with incrementing \texttt{time\_slices} over time. The system boots without errors and round-robin scheduling remains functional.

\section{Summary}

Week 1 establishes the complete foundational infrastructure for MLFQ scheduling:

\begin{itemize}
    \item \checkmark Four-level queue architecture with exponential time quanta (2, 4, 8, 16 ticks)
    \item \checkmark Extended \texttt{struct proc} with four MLFQ fields
    \item \checkmark \texttt{getprocinfo()} syscall for process information retrieval
    \item \checkmark Safe kernel-to-userspace data transfer via \texttt{copyout()}
    \item \checkmark Complete process lifecycle integration
    \item \checkmark ~60 lines of kernel code added
    \item \checkmark Backward compatibility with existing xv6 functionality
\end{itemize}

This foundation enables Week 2's scheduler implementation and Week 3's testing infrastructure.

\end{document}
